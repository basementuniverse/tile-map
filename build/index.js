/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Round n to d decimal places\n * @param {number} n The number to round\n * @param {number} [d=0] The number of decimal places to round to\n * @return {number} A rounded number\n */\nconst round = (n, d = 0) => {\n  const p = Math.pow(10, d);\n  return Math.round(n * p + Number.EPSILON) / p;\n}\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback InterpolationFunction\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst npr = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * Generate all combinations of r elements from an array\n *\n * @example\n * ```js\n * combinations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 3]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each combination\n * @return {Array<Array<*>>} An array of combination arrays\n */\nconst combinations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n};\n\n/**\n * Get a cartesian product of arrays\n *\n * @example\n * ```js\n * cartesian([1, 2, 3], ['a', 'b']);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, \"a\"],\n *   [1, \"b\"],\n *   [2, \"a\"],\n *   [2, \"b\"],\n *   [3, \"a\"],\n *   [3, \"b\"]\n * ]\n * ```\n */\nconst cartesian = (...arr) =>\n  arr.reduce(\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\n    [[]]\n  );\n\n/**\n * A function for generating array values\n * @callback TimesFunction\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {TimesFunction} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip 2 arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {Array<*>} a\n * @param {Array<*>} b\n * @return {Array<Array<*>>}\n */\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Return the last element of an array without removing it\n * @param {Array<*>} a\n * @return {*} The last element from the array\n */\nconst peek = (a) => {\n  if (!a.length) {\n    return undefined;\n  }\n\n  return a[a.length - 1];\n};\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\n/**\n * Flatten an object\n * @param {object} o\n * @param {string} concatenator The string to use for concatenating keys\n * @return {object} A flattened object\n */\nconst flat = (o, concatenator = '.') => {\n  return Object.keys(o).reduce((acc, key) => {\n    if (o[key] instanceof Date) {\n      return {\n        ...acc,\n        [key]: o[key].toISOString(),\n      };\n    }\n\n    if (typeof o[key] !== 'object' || !o[key]) {\n      return {\n        ...acc,\n        [key]: o[key],\n      };\n    }\n    const flattened = flat(o[key], concatenator);\n\n    return {\n      ...acc,\n      ...Object.keys(flattened).reduce(\n        (childAcc, childKey) => ({\n          ...childAcc,\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\n        }),\n        {}\n      ),\n    };\n  }, {});\n};\n\n/**\n * Unflatten an object\n * @param {object} o\n * @param {string} concatenator The string to check for in concatenated keys\n * @return {object} An un-flattened object\n */\nconst unflat = (o, concatenator = '.') => {\n  let result = {}, temp, substrings, property, i;\n\n  for (property in o) {\n    substrings = property.split(concatenator);\n    temp = result;\n    for (i = 0; i < substrings.length - 1; i++) {\n      if (!(substrings[i] in temp)) {\n        if (isFinite(substrings[i + 1])) {\n          temp[substrings[i]] = [];\n        } else {\n          temp[substrings[i]] = {};\n        }\n      }\n      temp = temp[substrings[i]];\n    }\n    temp[substrings[substrings.length - 1]] = o[property];\n  }\n\n  return result;\n};\n\n/**\n * A split predicate\n * @callback SplitPredicate\n * @param {any} value The current value\n * @return {boolean} True if the array should split at this index\n */\n\n/**\n * Split an array into sub-arrays based on a predicate\n * @param {Array<*>} array\n * @param {SplitPredicate} predicate\n * @return {Array<Array<*>>} An array of arrays\n */\nconst split = (array, predicate) => {\n  const result = [];\n  let current = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      if (current.length) {\n        result.push(current);\n      }\n      current = [value];\n    } else {\n      current.push(value);\n    }\n  }\n  result.push(current);\n\n  return result;\n};\n\n/**\n * Pluck keys from an object\n * @param {object} o\n * @param {...string} keys The keys to pluck from the object\n * @return {object} An object containing the plucked keys\n */\nconst pluck = (o, ...keys) => {\n  return keys.reduce(\n    (result, key) => Object.assign(result, { [key]: o[key] }),\n    {}\n  );\n};\n\n/**\n * Exclude keys from an object\n * @param {object} o\n * @param {...string} keys The keys to exclude from the object\n * @return {object} An object containing all keys except excluded keys\n */\nconst exclude = (o, ...keys) => {\n  return Object.fromEntries(\n    Object.entries(o).filter(([key]) => !keys.includes(key))\n  );\n};\n\nif (true) {\n  module.exports = {\n    floatEquals,\n    clamp,\n    frac,\n    round,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    npr,\n    ncr,\n    combinations,\n    cartesian,\n    times,\n    range,\n    zip,\n    at,\n    peek,\n    chunk,\n    shuffle,\n    flat,\n    unflat,\n    split,\n    pluck,\n    exclude,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/@basementuniverse/utils/utils.js?");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { times, chunk, dot } = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\n\n/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\n/**\n * A 2d vector\n * @typedef {Object} vec\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new vector\n * @param {number|vec} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec} A new vector\n * @example <caption>Various ways to initialise a vector</caption>\n * let a = vec(3, 2);  // (3, 2)\n * let b = vec(4);     // (4, 4)\n * let c = vec(a);     // (3, 2)\n * let d = vec();      // (0, 0)\n */\nconst vec = (x, y) => (!x && !y ?\n  { x: 0, y: 0 } : (typeof x === 'object' ?\n    { x: x.x || 0, y: x.y || 0 } : (y === null || y === undefined ?\n      { x: x, y: x } : { x: x, y: y })\n  )\n);\n\n/**\n * Get the components of a vector as an array\n * @param {vec} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec.components = a => [a.x, a.y];\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec} A unit vector (1, 0)\n */\nvec.ux = () => vec(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec} A unit vector (0, 1)\n */\nvec.uy = () => vec(0, 1);\n\n/**\n * Add vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a + b\n */\nvec.add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });\n\n/**\n * Scale a vector\n * @param {vec} a Vector a\n * @param {number} b Scalar b\n * @return {vec} a * b\n */\nvec.mul = (a, b) => ({ x: a.x * b, y: a.y * b });\n\n/**\n * Subtract vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {vec} a - b\n */\nvec.sub = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });\n\n/**\n * Get the length of a vector\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec} a Vector a\n * @return {number} |a|\n */\nvec.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec} a The vector to normalise\n * @return {vec} ^a\n */\nvec.nor = a => {\n  let len = vec.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {number} a ∙ b\n */\nvec.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec} A rotated vector\n */\nvec.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n}\n\n/**\n * Check if two vectors are equal\n * @param {vec} a Vector a\n * @param {vec} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec} a The vector to copy\n * @return {vec} A copy of vector a\n */\nvec.cpy = a => vec(a);\n\n/**\n * A function to call on each component of a vector\n * @callback vectorMapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec} a Vector a\n * @param {vectorMapCallback} f The function to call on each component of the vector\n * @return {vec} Vector a mapped through f\n */\nvec.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|boolean} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|boolean} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|boolean} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|boolean} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|boolean} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./node_modules/fast-rle/decode.js":
/*!*****************************************!*\
  !*** ./node_modules/fast-rle/decode.js ***!
  \*****************************************/
/***/ ((module) => {

eval("const decode = nums => {\n  const decoded = [];\n  for (let i = 0; i < nums.length; i += 2) {\n    const run_length = nums[i];\n    const value = nums[i + 1];\n    for (let ii = 0; ii < run_length; ii++) {\n      decoded.push(value);\n    }\n  }\n  return decoded;\n};\n\nmodule.exports = decode;\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/fast-rle/decode.js?");

/***/ }),

/***/ "./node_modules/lru_map/dist/lru.js":
/*!******************************************!*\
  !*** ./node_modules/lru_map/dist/lru.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("!function(g,c){ true?c(exports):0}(this,function(g){const c=Symbol(\"newer\"),e=Symbol(\"older\");class n{constructor(a,b){typeof a!==\"number\"&&(b=a,a=0),this.size=0,this.limit=a,this.oldest=this.newest=void 0,this._keymap=new Map(),b&&(this.assign(b),a<1&&(this.limit=this.size))}_markEntryAsUsed(a){if(a===this.newest)return;a[c]&&(a===this.oldest&&(this.oldest=a[c]),a[c][e]=a[e]),a[e]&&(a[e][c]=a[c]),a[c]=void 0,a[e]=this.newest,this.newest&&(this.newest[c]=a),this.newest=a}assign(a){let b,d=this.limit||Number.MAX_VALUE;this._keymap.clear();let m=a[Symbol.iterator]();for(let h=m.next();!h.done;h=m.next()){let f=new l(h.value[0],h.value[1]);this._keymap.set(f.key,f),b?(b[c]=f,f[e]=b):this.oldest=f,b=f;if(d--==0)throw new Error(\"overflow\")}this.newest=b,this.size=this._keymap.size}get(a){var b=this._keymap.get(a);return b?(this._markEntryAsUsed(b),b.value):void 0}set(a,b){var d=this._keymap.get(a);return d?(d.value=b,this._markEntryAsUsed(d),this):(this._keymap.set(a,d=new l(a,b)),this.newest?(this.newest[c]=d,d[e]=this.newest):this.oldest=d,this.newest=d,++this.size,this.size>this.limit&&this.shift(),this)}shift(){var a=this.oldest;if(a)return this.oldest[c]?(this.oldest=this.oldest[c],this.oldest[e]=void 0):(this.oldest=void 0,this.newest=void 0),a[c]=a[e]=void 0,this._keymap.delete(a.key),--this.size,[a.key,a.value]}find(a){let b=this._keymap.get(a);return b?b.value:void 0}has(a){return this._keymap.has(a)}delete(a){var b=this._keymap.get(a);return b?(this._keymap.delete(b.key),b[c]&&b[e]?(b[e][c]=b[c],b[c][e]=b[e]):b[c]?(b[c][e]=void 0,this.oldest=b[c]):b[e]?(b[e][c]=void 0,this.newest=b[e]):this.oldest=this.newest=void 0,this.size--,b.value):void 0}clear(){this.oldest=this.newest=void 0,this.size=0,this._keymap.clear()}keys(){return new j(this.oldest)}values(){return new k(this.oldest)}entries(){return this}[Symbol.iterator](){return new i(this.oldest)}forEach(a,b){typeof b!==\"object\"&&(b=this);let d=this.oldest;for(;d;)a.call(b,d.value,d.key,this),d=d[c]}toJSON(){for(var a=new Array(this.size),b=0,d=this.oldest;d;)a[b++]={key:d.key,value:d.value},d=d[c];return a}toString(){for(var a=\"\",b=this.oldest;b;)a+=String(b.key)+\":\"+b.value,b=b[c],b&&(a+=\" < \");return a}}g.LRUMap=n;function l(a,b){this.key=a,this.value=b,this[c]=void 0,this[e]=void 0}function i(a){this.entry=a}i.prototype[Symbol.iterator]=function(){return this},i.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:[a.key,a.value]}):{done:!0,value:void 0}};function j(a){this.entry=a}j.prototype[Symbol.iterator]=function(){return this},j.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.key}):{done:!0,value:void 0}};function k(a){this.entry=a}k.prototype[Symbol.iterator]=function(){return this},k.prototype.next=function(){let a=this.entry;return a?(this.entry=a[c],{done:!1,value:a.value}):{done:!0,value:void 0}}});\n//# sourceMappingURL=lru.js.map\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./node_modules/lru_map/dist/lru.js?");

/***/ }),

/***/ "./bitmap-decompose.ts":
/*!*****************************!*\
  !*** ./bitmap-decompose.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bitmapToRectangles = void 0;\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nfunction bitmapToRectangles(bitmap) {\n    const rectangles = [];\n    // Step 1 - create 1-unit tall rectangles for each row\n    for (const [y, row] of bitmap.entries()) {\n        let currentRectangle = null;\n        for (let x = 0; x < row.length; x++) {\n            if (row[x]) {\n                if (!currentRectangle) {\n                    currentRectangle = {\n                        position: (0, vec_1.vec)(x, y),\n                        size: (0, vec_1.vec)(1, 1),\n                    };\n                }\n                else {\n                    currentRectangle.size.x++;\n                }\n            }\n            else {\n                if (currentRectangle) {\n                    rectangles.push(currentRectangle);\n                    currentRectangle = null;\n                }\n            }\n        }\n    }\n    // Step 2 - extend each rectangle downwards if possible\n    let pair;\n    while (pair = findRectangleToExtend(rectangles)) {\n        const [a, b] = pair;\n        rectangles.splice(indexOf(b, rectangles), 1, ...chopRectangle(b, a));\n        a.size.y += b.size.y;\n    }\n    return rectangles;\n}\nexports.bitmapToRectangles = bitmapToRectangles;\n/**\n * Get the index of rectangle a in a list of rectangles\n */\nfunction indexOf(a, rectangles) {\n    return rectangles.findIndex(b => vec_1.vec.eq(a.position, b.position) && vec_1.vec.eq(a.size, b.size));\n}\n/**\n * Find a pair of rectangles where the first one can be extended into the\n * second one\n *\n * If no such pair exists, return null\n */\nfunction findRectangleToExtend(rectangles) {\n    for (const a of rectangles) {\n        const b = findRectangleToExtendInto(a, rectangles);\n        if (b) {\n            return [a, b];\n        }\n    }\n    return null;\n}\n/**\n * Find a rectangle which rectangle a can extend into, or null if none can be\n * found\n *\n * A rectangle can extend into another one if the other one is exactly below\n * and their x-axis projections overlap\n */\nfunction findRectangleToExtendInto(a, rectangles) {\n    var _a;\n    return (_a = rectangles.find(other => (\n    // The other rectangle is exactly below the current one\n    other.position.y === a.position.y + a.size.y &&\n        // The other rectangle starts before (or at) the start of the current one\n        other.position.x <= a.position.x &&\n        // The other rectangle ends after (or at) the end of the current one\n        other.position.x + other.size.x >= a.position.x + a.size.x))) !== null && _a !== void 0 ? _a : null;\n}\n/**\n * Subtract rectangle b from rectangle a, ignoring height (i.e. only in the\n * x-axis) and return 0, 1 or 2 resulting rectangles\n */\nfunction chopRectangle(a, b) {\n    const result = [];\n    if (b.position.x > a.position.x) {\n        result.push({\n            position: (0, vec_1.vec)(a.position.x, a.position.y),\n            size: (0, vec_1.vec)(b.position.x - a.position.x, a.size.y),\n        });\n    }\n    if (b.position.x + b.size.x < a.position.x + a.size.x) {\n        result.push({\n            position: (0, vec_1.vec)(b.position.x + b.size.x, a.position.y),\n            size: (0, vec_1.vec)((a.position.x + a.size.x) - (b.position.x + b.size.x), a.size.y),\n        });\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./bitmap-decompose.ts?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tileMapOptionsContentProcessor = exports.TileMap = exports.TileAlignment = void 0;\nconst lru_map_1 = __webpack_require__(/*! lru_map */ \"./node_modules/lru_map/dist/lru.js\");\nconst decode_1 = __importDefault(__webpack_require__(/*! fast-rle/decode */ \"./node_modules/fast-rle/decode.js\"));\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nconst utils_1 = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\nconst bitmap_decompose_1 = __webpack_require__(/*! ./bitmap-decompose */ \"./bitmap-decompose.ts\");\nvar TileAlignment;\n(function (TileAlignment) {\n    TileAlignment[TileAlignment[\"TopLeft\"] = 0] = \"TopLeft\";\n    TileAlignment[TileAlignment[\"Top\"] = 1] = \"Top\";\n    TileAlignment[TileAlignment[\"TopRight\"] = 2] = \"TopRight\";\n    TileAlignment[TileAlignment[\"Left\"] = 3] = \"Left\";\n    TileAlignment[TileAlignment[\"Center\"] = 4] = \"Center\";\n    TileAlignment[TileAlignment[\"Right\"] = 5] = \"Right\";\n    TileAlignment[TileAlignment[\"BottomLeft\"] = 6] = \"BottomLeft\";\n    TileAlignment[TileAlignment[\"Bottom\"] = 7] = \"Bottom\";\n    TileAlignment[TileAlignment[\"BottomRight\"] = 8] = \"BottomRight\";\n})(TileAlignment = exports.TileAlignment || (exports.TileAlignment = {}));\nfunction pointInRectangle(point, topLeft, bottomRight) {\n    return (point.x >= topLeft.x &&\n        point.y >= topLeft.y &&\n        point.x < bottomRight.x &&\n        point.y < bottomRight.y);\n}\nclass TileMap {\n    constructor(options) {\n        const actualOptions = Object.assign({}, TileMap.DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n        if (!actualOptions.debug || actualOptions.debug === true) {\n            actualOptions.debug = {\n                showOrigin: !!actualOptions.debug,\n                showChunkBorders: !!actualOptions.debug,\n                showChunkLabels: !!actualOptions.debug,\n                showTileBorders: !!actualOptions.debug,\n            };\n        }\n        this.options = actualOptions;\n        this.chunkBuffer = new lru_map_1.LRUMap(this.options.chunkBufferMaxSize);\n    }\n    /**\n     * Get a (roughly minimal) set of rectangles which cover the tiles in a\n     * given layer\n     *\n     * @param layerName The name of the layer to get rectangles for\n     * @param fieldName We will check the truthyness of this field in the\n     * tile definition\n     * @param tileBounds Optional bounds to check within, relative to bounds\n     * defined in options if any exist, otherwise relative to (0, 0)\n     */\n    getLayerRectangles(layerName, fieldName, tileBounds) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        const layer = this.options.layers.find((l) => l.name === layerName);\n        if (!layer) {\n            return [];\n        }\n        const topLeft = (_a = tileBounds === null || tileBounds === void 0 ? void 0 : tileBounds.topLeft) !== null && _a !== void 0 ? _a : (0, vec_1.vec)(0);\n        const bottomRight = (_b = tileBounds === null || tileBounds === void 0 ? void 0 : tileBounds.bottomRight) !== null && _b !== void 0 ? _b : (0, vec_1.vec)(Math.max(...(_d = (_c = layer.data) === null || _c === void 0 ? void 0 : _c.map(row => row.length)) !== null && _d !== void 0 ? _d : [0]), (_f = (_e = layer.data) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0);\n        if (bottomRight.x <= topLeft.x || bottomRight.y <= topLeft.y) {\n            return [];\n        }\n        const bitmap = [];\n        for (let y = topLeft.y; y < bottomRight.y; y++) {\n            const row = [];\n            for (let x = topLeft.x; x < bottomRight.x; x++) {\n                const tileData = (_h = (_g = layer.data) === null || _g === void 0 ? void 0 : _g[y]) === null || _h === void 0 ? void 0 : _h[x];\n                if (tileData === undefined || tileData === -1) {\n                    row.push(false);\n                    continue;\n                }\n                const tile = (_j = layer.tiles) === null || _j === void 0 ? void 0 : _j[tileData];\n                if (!tile) {\n                    row.push(false);\n                    continue;\n                }\n                if (fieldName && !tile[fieldName]) {\n                    row.push(false);\n                    continue;\n                }\n                row.push(true);\n            }\n            bitmap.push(row);\n        }\n        return (0, bitmap_decompose_1.bitmapToRectangles)(bitmap);\n    }\n    /**\n     * Get the tile at a given position and in the specified layer\n     *\n     * If no layer is specified, return a dictionary of layer names to tile\n     * definitions (i.e. return all layers)\n     *\n     * If no tile exists at this position, return null\n     */\n    getTileAtPosition(position, layerName) {\n        if (layerName) {\n            return this.getTileAtPositionInLayer(position, layerName);\n        }\n        const result = {};\n        for (const layer of this.options.layers) {\n            result[layer.name] = this.getTileAtPositionInLayer(position, layer.name);\n        }\n        return result;\n    }\n    getTileAtPositionInLayer(position, layerName) {\n        var _a, _b, _c;\n        const tilePosition = vec_1.vec.map(vec_1.vec.mul(position, 1 / this.options.tileSize), Math.floor);\n        const layer = this.options.layers.find((l) => l.name === layerName);\n        if (!layer) {\n            return null;\n        }\n        const tileData = (_b = (_a = layer.data) === null || _a === void 0 ? void 0 : _a[tilePosition.y]) === null || _b === void 0 ? void 0 : _b[tilePosition.x];\n        if (tileData === undefined || tileData === -1) {\n            return null;\n        }\n        if (layer.tiles) {\n            return (_c = layer.tiles[tileData]) !== null && _c !== void 0 ? _c : null;\n        }\n        return null;\n    }\n    hashVector(v) {\n        return vec_1.vec.str(v);\n    }\n    draw(context, screen, position, scale) {\n        var _a, _b, _c, _d;\n        const absoluteChunkSize = this.options.tileSize * this.options.chunkSize;\n        const chunkBorder = (0, vec_1.vec)(this.options.chunkBorder);\n        // Maybe clamp scale\n        let actualScale = scale;\n        if (this.options.minScale && actualScale < this.options.minScale) {\n            actualScale = this.options.minScale;\n        }\n        if (this.options.maxScale && actualScale > this.options.maxScale) {\n            actualScale = this.options.maxScale;\n        }\n        // Maybe clamp position to bounds\n        let actualPosition = (0, vec_1.vec)(position);\n        if (this.options.bounds && this.options.clampPositionToBounds) {\n            const tileSizeScaled = this.options.tileSize / actualScale;\n            const halfScreenScaled = vec_1.vec.map(vec_1.vec.mul(screen, 1 / (actualScale * 2)), Math.ceil);\n            const minPosition = (0, vec_1.vec)(this.options.bounds.topLeft.x * tileSizeScaled + halfScreenScaled.x, this.options.bounds.topLeft.y * tileSizeScaled + halfScreenScaled.y);\n            const maxPosition = (0, vec_1.vec)(this.options.bounds.bottomRight.x * tileSizeScaled - halfScreenScaled.x, this.options.bounds.bottomRight.y * tileSizeScaled - halfScreenScaled.y);\n            actualPosition = (0, vec_1.vec)((0, utils_1.clamp)(actualPosition.x, minPosition.x, maxPosition.x), (0, utils_1.clamp)(actualPosition.y, minPosition.y, maxPosition.y));\n        }\n        const screenSizeInChunks = vec_1.vec.map(vec_1.vec.mul(screen, 1 / (absoluteChunkSize * actualScale)), Math.ceil);\n        const screenCenterChunk = vec_1.vec.map(vec_1.vec.mul(actualPosition, 1 / absoluteChunkSize), Math.floor);\n        const topLeftChunk = vec_1.vec.sub(vec_1.vec.sub(screenCenterChunk, vec_1.vec.map(vec_1.vec.mul(screenSizeInChunks, 0.5), Math.ceil)), chunkBorder);\n        const bottomRightChunk = vec_1.vec.add(vec_1.vec.add(screenCenterChunk, vec_1.vec.map(vec_1.vec.mul(screenSizeInChunks, 0.5), Math.ceil)), chunkBorder);\n        context.save();\n        context.scale(actualScale, actualScale);\n        context.translate(-actualPosition.x + screen.x / (actualScale * 2), -actualPosition.y + screen.y / (actualScale * 2));\n        (_b = (_a = this.options).preRender) === null || _b === void 0 ? void 0 : _b.call(_a, context, this, screen, actualPosition, actualScale);\n        // Render chunks\n        for (let y = topLeftChunk.y; y < bottomRightChunk.y; y++) {\n            for (let x = topLeftChunk.x; x < bottomRightChunk.x; x++) {\n                const chunkPosition = (0, vec_1.vec)(x, y);\n                const chunkAbsolutePosition = vec_1.vec.mul(chunkPosition, absoluteChunkSize);\n                // Check if we have this chunk in the cache\n                const chunkHash = this.hashVector(chunkPosition);\n                if (!this.chunkBuffer.has(chunkHash)) {\n                    this.chunkBuffer.set(chunkHash, this.generateChunk(chunkPosition, absoluteChunkSize));\n                }\n                const chunk = this.chunkBuffer.get(chunkHash);\n                if (chunk) {\n                    context.drawImage(chunk.image, chunkAbsolutePosition.x, chunkAbsolutePosition.y);\n                }\n            }\n        }\n        (_d = (_c = this.options).postRender) === null || _d === void 0 ? void 0 : _d.call(_c, context, this, screen, actualPosition, actualScale);\n        // Render debug helpers\n        if (this.options.debug.showTileBorders) {\n            const topLeftTile = vec_1.vec.mul(vec_1.vec.sub(screenCenterChunk, vec_1.vec.add(vec_1.vec.map(vec_1.vec.mul(screenSizeInChunks, 0.5), Math.ceil), (0, vec_1.vec)(1))), this.options.chunkSize);\n            const bottomRightTile = vec_1.vec.mul(vec_1.vec.add(screenCenterChunk, vec_1.vec.add(vec_1.vec.map(vec_1.vec.mul(screenSizeInChunks, 0.5), Math.ceil), (0, vec_1.vec)(1))), this.options.chunkSize);\n            for (let y = topLeftTile.y; y < bottomRightTile.y; y++) {\n                this.drawLine(context, (0, vec_1.vec)(actualPosition.x - screen.x / (actualScale * 2), y * this.options.tileSize), (0, vec_1.vec)(actualPosition.x + screen.x / (actualScale * 2), y * this.options.tileSize), TileMap.DEBUG_TILE_BORDER_COLOUR, TileMap.DEBUG_TILE_BORDER_LINE_WIDTH);\n            }\n            for (let x = topLeftTile.x; x < bottomRightTile.x; x++) {\n                this.drawLine(context, (0, vec_1.vec)(x * this.options.tileSize, actualPosition.y - screen.y / (actualScale * 2)), (0, vec_1.vec)(x * this.options.tileSize, actualPosition.y + screen.y / (actualScale * 2)), TileMap.DEBUG_TILE_BORDER_COLOUR, TileMap.DEBUG_TILE_BORDER_LINE_WIDTH);\n            }\n        }\n        if (this.options.debug.showChunkBorders) {\n            for (let y = topLeftChunk.y; y < bottomRightChunk.y; y++) {\n                this.drawLine(context, (0, vec_1.vec)(actualPosition.x - screen.x / (actualScale * 2), y * absoluteChunkSize), (0, vec_1.vec)(actualPosition.x + screen.x / (actualScale * 2), y * absoluteChunkSize), TileMap.DEBUG_CHUNK_BORDER_COLOUR, TileMap.DEBUG_CHUNK_BORDER_LINE_WIDTH);\n            }\n            for (let x = topLeftChunk.x; x < bottomRightChunk.x; x++) {\n                this.drawLine(context, (0, vec_1.vec)(x * absoluteChunkSize, actualPosition.y - screen.y / (actualScale * 2)), (0, vec_1.vec)(x * absoluteChunkSize, actualPosition.y + screen.y / (actualScale * 2)), TileMap.DEBUG_CHUNK_BORDER_COLOUR, TileMap.DEBUG_CHUNK_BORDER_LINE_WIDTH);\n            }\n        }\n        if (this.options.debug.showChunkLabels) {\n            context.save();\n            context.fillStyle = TileMap.DEBUG_CHUNK_LABEL_COLOUR;\n            context.font = TileMap.DEBUG_CHUNK_LABEL_FONT;\n            context.textBaseline = 'middle';\n            context.textAlign = 'center';\n            for (let y = topLeftChunk.y; y < bottomRightChunk.y; y++) {\n                for (let x = topLeftChunk.x; x < bottomRightChunk.x; x++) {\n                    context.fillText(`${x}, ${y}`, x * absoluteChunkSize + absoluteChunkSize / 2, y * absoluteChunkSize + absoluteChunkSize / 2);\n                }\n            }\n            context.restore();\n        }\n        if (this.options.debug.showOrigin &&\n            pointInRectangle((0, vec_1.vec)(0, 0), topLeftChunk, bottomRightChunk)) {\n            this.drawCross(context, (0, vec_1.vec)(0, 0), TileMap.DEBUG_ORIGIN_COLOUR, TileMap.DEBUG_ORIGIN_LINE_WIDTH, TileMap.DEBUG_ORIGIN_SIZE);\n        }\n        context.restore();\n    }\n    generateChunk(chunkPosition, absoluteChunkSize) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const chunkCanvas = document.createElement('canvas');\n        const chunkContext = chunkCanvas.getContext('2d');\n        chunkCanvas.width = absoluteChunkSize;\n        chunkCanvas.height = absoluteChunkSize;\n        let chunk = {\n            chunkPosition,\n            image: chunkCanvas,\n        };\n        const topLeftTile = vec_1.vec.mul(chunkPosition, this.options.chunkSize);\n        const bottomRightTile = vec_1.vec.add(topLeftTile, (0, vec_1.vec)(this.options.chunkSize - 1));\n        const boundsTopLeft = (_b = (_a = this.options.bounds) === null || _a === void 0 ? void 0 : _a.topLeft) !== null && _b !== void 0 ? _b : (0, vec_1.vec)(0);\n        if (this.options.preGenerateChunk) {\n            const result = this.options.preGenerateChunk(chunkContext, this, {\n                topLeft: topLeftTile,\n                bottomRight: bottomRightTile,\n            }, chunkPosition);\n            if (Array.isArray(result)) {\n                if (!result[1]) {\n                    return chunk;\n                }\n            }\n        }\n        // Default generation, render tiles from tilemap data\n        for (const layer of this.options.layers) {\n            chunkContext.save();\n            chunkContext.globalAlpha = (_c = layer.opacity) !== null && _c !== void 0 ? _c : 1;\n            const alignment = (_d = layer.alignment) !== null && _d !== void 0 ? _d : TileAlignment.Center;\n            for (let y = topLeftTile.y; y <= bottomRightTile.y; y++) {\n                for (let x = topLeftTile.x; x <= bottomRightTile.x; x++) {\n                    const tilePosition = (0, vec_1.vec)(x, y);\n                    (_e = layer.preRenderTile) === null || _e === void 0 ? void 0 : _e.call(layer, chunkContext, this, layer, chunkPosition, tilePosition);\n                    const tileDataPosition = vec_1.vec.sub(tilePosition, boundsTopLeft);\n                    if (tileDataPosition.x < 0 || tileDataPosition.y < 0) {\n                        continue;\n                    }\n                    const tileData = (_g = (_f = layer.data) === null || _f === void 0 ? void 0 : _f[tileDataPosition.y]) === null || _g === void 0 ? void 0 : _g[tileDataPosition.x];\n                    if (tileData === undefined || tileData === -1) {\n                        continue;\n                    }\n                    const tileImage = (_j = (_h = layer.tiles) === null || _h === void 0 ? void 0 : _h[tileData]) === null || _j === void 0 ? void 0 : _j.image;\n                    if (!tileImage) {\n                        continue;\n                    }\n                    const tileAbsolutePosition = vec_1.vec.sub(vec_1.vec.mul(tilePosition, this.options.tileSize), vec_1.vec.mul(chunkPosition, absoluteChunkSize));\n                    // Tile clipping\n                    if (layer.clip) {\n                        chunkContext.save();\n                        chunkContext.beginPath();\n                        chunkContext.rect(tileAbsolutePosition.x, tileAbsolutePosition.y, this.options.tileSize, this.options.tileSize);\n                        chunkContext.clip();\n                    }\n                    // Tile alignment\n                    let tileImageAbsolutePosition;\n                    switch (alignment) {\n                        case TileAlignment.TopLeft:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition);\n                            break;\n                        case TileAlignment.Top:\n                            tileImageAbsolutePosition = (0, vec_1.vec)((tileAbsolutePosition.x + this.options.tileSize / 2) - tileImage.width / 2, tileAbsolutePosition.y);\n                            break;\n                        case TileAlignment.TopRight:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x + this.options.tileSize - tileImage.width, tileAbsolutePosition.y);\n                            break;\n                        case TileAlignment.Left:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x, (tileAbsolutePosition.y + this.options.tileSize / 2) - tileImage.height / 2);\n                            break;\n                        case TileAlignment.Center:\n                            tileImageAbsolutePosition = (0, vec_1.vec)((tileAbsolutePosition.x + this.options.tileSize / 2) - tileImage.width / 2, (tileAbsolutePosition.y + this.options.tileSize / 2) - tileImage.height / 2);\n                            break;\n                        case TileAlignment.Right:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x + this.options.tileSize - tileImage.width, (tileAbsolutePosition.y + this.options.tileSize / 2) - tileImage.height / 2);\n                            break;\n                        case TileAlignment.BottomLeft:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x, tileAbsolutePosition.y + this.options.tileSize - tileImage.height);\n                            break;\n                        case TileAlignment.Bottom:\n                            tileImageAbsolutePosition = (0, vec_1.vec)((tileAbsolutePosition.x + this.options.tileSize / 2) - tileImage.width / 2, tileAbsolutePosition.y + this.options.tileSize - tileImage.height);\n                            break;\n                        case TileAlignment.BottomRight:\n                            tileImageAbsolutePosition = (0, vec_1.vec)(tileAbsolutePosition.x + this.options.tileSize - tileImage.width, tileAbsolutePosition.y + this.options.tileSize - tileImage.height);\n                            break;\n                    }\n                    chunkContext.drawImage(tileImage, tileImageAbsolutePosition.x, tileImageAbsolutePosition.y);\n                    if (layer.clip) {\n                        chunkContext.restore();\n                    }\n                    (_k = layer.postRenderTile) === null || _k === void 0 ? void 0 : _k.call(layer, chunkCanvas, chunkContext, this, layer, chunkPosition, tilePosition);\n                }\n            }\n            chunkContext.restore();\n        }\n        (_m = (_l = this.options).postGenerateChunk) === null || _m === void 0 ? void 0 : _m.call(_l, chunkCanvas, chunkContext, this, {\n            topLeft: topLeftTile,\n            bottomRight: bottomRightTile,\n        }, chunkPosition);\n        return chunk;\n    }\n    drawLine(context, start, end, colour, lineWidth) {\n        context.save();\n        context.lineWidth = lineWidth;\n        context.strokeStyle = colour;\n        context.beginPath();\n        context.moveTo(start.x, start.y);\n        context.lineTo(end.x, end.y);\n        context.stroke();\n        context.restore();\n    }\n    drawCross(context, position, colour, lineWidth, size) {\n        context.save();\n        context.lineWidth = lineWidth;\n        const halfSize = Math.ceil(size / 2);\n        context.strokeStyle = colour;\n        context.beginPath();\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n        context.restore();\n    }\n}\nexports.TileMap = TileMap;\nTileMap.DEFAULT_OPTIONS = {\n    clampPositionToBounds: true,\n    tileSize: 16,\n    layers: [\n        {\n            name: 'default',\n        },\n    ],\n    chunkSize: 8,\n    chunkBorder: 1,\n    chunkBufferMaxSize: 64,\n};\nTileMap.DEBUG_ORIGIN_COLOUR = 'cyan';\nTileMap.DEBUG_ORIGIN_LINE_WIDTH = 2;\nTileMap.DEBUG_ORIGIN_SIZE = 10;\nTileMap.DEBUG_CHUNK_BORDER_COLOUR = 'yellow';\nTileMap.DEBUG_CHUNK_BORDER_LINE_WIDTH = 2;\nTileMap.DEBUG_CHUNK_LABEL_COLOUR = 'white';\nTileMap.DEBUG_CHUNK_LABEL_FONT = '12px monospace';\nTileMap.DEBUG_TILE_BORDER_COLOUR = 'orange';\nTileMap.DEBUG_TILE_BORDER_LINE_WIDTH = 1;\n/**\n * Content Manager Processor wrapper which converts TileMapOptionsData into\n * TileMapOptions\n *\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\n */\nasync function tileMapOptionsContentProcessor(content, data, options) {\n    const getImageFromContent = (name) => {\n        var _a;\n        const image = (_a = content[name]) === null || _a === void 0 ? void 0 : _a.content;\n        if (!image) {\n            throw new Error(`Image '${name}' not found`);\n        }\n        return image;\n    };\n    const result = data.content;\n    if (result.layers) {\n        for (const [i, layer] of result.layers.entries()) {\n            // Replace imageName with image in the tile definitions array\n            if (layer.tiles) {\n                for (const [j, tile] of layer.tiles.entries()) {\n                    result.layers[i].tiles[j].image = getImageFromContent(tile.imageName);\n                    delete result.layers[i].tiles[j].imageName;\n                }\n            }\n            // Decompress layer data\n            if ((options === null || options === void 0 ? void 0 : options.decompressData) && layer.data && layer.width) {\n                result.layers[i].data = (0, utils_1.chunk)((0, decode_1.default)(layer.data), layer.width);\n                delete result.layers[i].width;\n            }\n        }\n    }\n    // @ts-ignore\n    data.content = result;\n}\nexports.tileMapOptionsContentProcessor = tileMapOptionsContentProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/tile-map/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});